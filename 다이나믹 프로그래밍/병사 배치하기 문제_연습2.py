# n명의 병사가 있는데 각각 전투력을 가지고 있음
# 전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치하고자 함
# 앞쪽의 병사는 뒤쪽의 병사보다 항상 전투력이 높아야 함(같으면 안 됨)
# 특정 위치의 병사를 열외하는 방법을 사용
# 남아있는 병사의 수를 최대로 하는 열외시켜야 하는 병사의 수를 출력하라.

n = int(input()) # 1 <= n <= 2000
arr = list(map(int, input().split())) # 전투력은 1,000,000과 같거나 작은 자연수 
arr.reverse() # 가장 긴 증가하는 부분 수열 문제로 바꿔서 풀기 위해 수열을 뒤집어줌.
# arr = arr[::-1]
dp = [1] * n # 수열의 원소가 1개인 경우 길이가 1이기 때문에 배열을 1로 초기화

# 가장 긴 증가하는 부분 수열을 해결하는 알고리즘
# 모든 0 <= j < i에 대하여, dp[i] = max(dp[i], dp[j] + 1) if array[j] < array[i]
for i in range(1, n): # 0 ~ n - 1
    for j in range(i): # 0 ~ i - 1
        if arr[j] < arr[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(n - max(dp)) # 열외시켜야 하는 병사의 수를 출력하는 것이기 때문에

'''
n이 2000이기 때문에 가능하면 O(n**2) 이하의 시간 복잡도를 가지는 알고리즘 사용해야 함.
n**2 = 4,000,000

7
15 11 4 8 5 2 4

2
'''