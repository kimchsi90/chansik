# 다이나믹 프로그래밍
# 탑다운(하향식) 방식으로 피보나치 수열 구현
# 구현 과정에서 재귀 함수를 이용하며 큰 문제를 해결하기 위해 작은 문제들을 재귀적으로 호출하여 작은 문제들이 모두 해결되었을 때 큰 문제에 대한 답을 얻을 수 있도록 구현.
# 그러한 과정에서 한 번 계산된 값들을 기록하기 위해 메모이제이션 기법을 이용.


def fibo(n):
    print(f'f({n})', end = ' ')
    # 종료 조건 (1 혹은 2 일 때 1을 반환)
    if n == 1 or n == 2:
        return 1
    
    # 이미 계산한 적이 있다면 그 값을 사용하여 반환
    if dp[n] != 0:
        return dp[n]
    # 아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환
    dp[n] = fibo(n - 1) + fibo(n - 2)

    return dp[n]


dp = [0] * 100

print(fibo(6))

'''
메모이제이션 기법을 이용한 경우 피보나치 수열의 시간 복잡도는 O(N)이다.
N이 아무리 커진다고 해도 메모리 공간을 N만큼 가질 수 있다면 충분히 선형 시간 알고리즘으로도 피보나치 수열을 해결할 수 있음.
이미 계산된 결과는 상수 시간으로 return하도록 되어 있기 때문에 특정 번째 피보나치 수열을 구하는 과정에서 걸리는 시간은 O(N)이 될 것을 기대할 수 있다.
'''
