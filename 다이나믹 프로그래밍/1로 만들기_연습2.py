n = int(input())

'''
1. x가 5로 나누어 떨어지면 5로 나눔
2. x가 3로 나누어 떨어지면 3로 나눔
3. x가 2로 나누어 떨어지면 2로 나눔
4. x에서 1을 뺌

입력 x에 대해 연산 4개를 적절히 활용하여 1을 만들고자 한다.
연산을 사용하는 횟수의 최솟값을 출력하시오.

각 문제는 작은 문제들을 조합해서 해결할 수 있기 때문에 최적 부분 구조라고 할 수 있다.
(DP 사용 조건 1번)

그리고 동일한 문제가 여러 번 호출되기 때문에 중복되는 부분 문제를 가진다.
(DP 사용 조건 2번)

ex.
        f6
    f5  f3  f2
f4 f1 f2 f1 f1 f1

f(6)은 1을 뺀 f5와 2로 나눈 f3과 3으로 나눈 f2를 호출하여 최솟값을 비교함
f5, f3, f2와 같은 작은 문제들을 조합해서 해결 가능 -> 최적 부분 구조
f5는 다시 f4와 f1을 호출... 하기 때문에 중복되는 부분 문제를 가진다.

'''

dp = [0] * (n + 1)
# INF = 10**9

# for i in range(2, n + 1):
#     if i % 5 == 0:
#         a = dp[i//5]
#     else:
#         a = INF
    
#     if i % 3 == 0:
#         b = dp[i//3]
#     else:
#         b = INF
    
#     if i % 2 == 0:
#         c = dp[i//2]
#     else:
#         c = INF

#     d = dp[i-1]

#     dp[i] = min(a, b, c, d) + 1


for i in range(2, n + 1):
    dp[i] = dp[i - 1] + 1

    if i % 2 == 0:
        dp[i] == min(dp[i], dp[i//2] + 1)
    if i % 3 == 0:
        dp[i] == min(dp[i], dp[i//3] + 1)
    if i % 5 == 0:
        dp[i] == min(dp[i], dp[i//5] + 1)

print(dp[n])

'''
26

3
'''