n, m = map(int, input().split())
coins = [int(input()) for _ in range(n)]

# 1 <= n <= 100 개의 줄에 각 화폐의 가치가 주어진다.
# 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 1 <= m <= 10,000 원이 되도록 하려고 한다.
# 각 종류의 화폐는 몇 개라도 사용할 수 있음.
# m원을 만들기 위한 최소한의 화폐 개수를 출력하시오.
# 불가능할 때는 -1을 출력한다.

INF = 10001 # m이 최대 1만이기 때문에
dp = [INF] * (m + 1) # 0~m까지의 dp 테이블을 만든다. 여기에는 각 인덱스 값의 돈을 만들기 위한 최소한의 화폐 개수가 들어간다.
# dp 테이블을 어떤 값으로 초기화할 것인가? 0 or INF?
# INF는 특정 금액을 만들 수 있는 방법이 존재하지 않는다는 의미로 사용.

# DP 바텀업 방식은 dp[0] = 0같이 최초의 값을 초기화 해준다.
dp[0] = 0

for i in range(min(coins), m + 1):
    for coin in coins:
        if dp[i - coin] != INF: # i - coin원을 만드는 방법이 존재하는 경우
            dp[i] = min(dp[i], dp[i - coin] + 1)

if dp[m] != INF:
    print(dp[m])
else:
    print(-1)

'''
0 값은 화폐 0개로 만들 수 있기 때문에 0으로 초기화. 나머지 값들은 화폐를 구성할 수 없다는 의미의 INF로 초기화.
각 최소 화폐 단위부터 반복문을 시작해 구하고자 하는 값 m까지 돈다.
각 값에서 2중 반복문으로 화폐 단위 coin을 돌며 i 값을 정하기 위해 i-coin 값이 INF가 아닌지 확인하고
INF가 아닐 경우 dp 테이블에 저장된 dp[i]와 dp[i-coin]+1 중 작은 것을 선택하여 저장한다.
(i-coin을 만들 수 있을 경우 i 또한 만들 수 있다)

이렇게 구현할 경우 n * m 만큼의 연산이 수행된다.
시간 복잡도는 O(n * m)인데 n은 최대 100, m은 최대 10,000으로 n*m은 최대 100만이다.
시간 제한은 1초기 때문에 이렇게 구현해도 된다.
'''



'''
2 15
2
3

5
-----
3 4
3
5
7

-1
'''



