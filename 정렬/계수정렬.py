# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

# 데이터의 개수만큼 count를 체크하므로 O(N)
for i in range(len(array)):
    count[array[i]] += 1  # 각 데이터에 해당하는 인덱스의 값 증가

# 원소 중 가장 큰 값을 의미하는 K 만큼 그 인덱스를 확인하며, 기록되어 있는 만큼(N) 출력을 수행. 안쪽 반복문은 전체 수행 횟수가 N.
# 이중 반복문의 시간 복잡도는 N+K
for i in range(len(count)):  # 0~9: 원소 중 가장 큰 값을 의미하는 K만큼 반복
    for j in range(count[i]): # 전체 반복 횟수는 array의 길이인 N만큼 반복
        print(i, end=" ")  # 등장 횟수만큼 인덱스 출력

# 전체 시간 복잡도는 단순히 O(N+K)라고 할 수 있음.
# 공간 복잡도는 array의 길이 N + count의 길이 K만큼 필요하기 때문에 O(N + K)

'''
시간 복잡도: O(N)
첫번째 반복문의 횟수 N, 두 번째 반복문의 횟수: N

공간 복잡도: O(N + K)
num, i, j 변수 이외에 array의 길이인 N, count의 길이인 array의 최댓값 K만큼 공간이 필요하여 O(N + K)이다.

데이터의 범위가 너무 큰 경우 심각한 비효율성을 초래할 수 있음. array = [0, 9999]인 경우 10000만큼의 공간이 필요함

효율적으로 사용할 수 있는 경우는 동일한 값들이 지속적으로 발생하는 경우 ex. 시험 점수(0~100). 데이터의 공간이 한정적이면서 정렬할 데이터가 많은 경우. 이런 조건만 만족한다면 매우 빠르게 동작함.
'''